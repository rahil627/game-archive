
# install
# https://hexdocs.pm/phoenix/installation.html
scoop install erlang
scoop install elixir
scoop install postgresql

# Run run 'pg_ctl start' or 'pg_ctl stop' to start and stop the database or register it as a service by running 'pg_ctl register -N PostgreSQL' from an elevated shell.

# install elixir's package manager
mix local.hex

# install phoenix's app generator
mix archive.install hex phx_new




# get a server up and runnin'
# check options before creating a new project
# (great documentation via cli!)
# uses postgressql by default
# can try bandit http server over the default cowboy
#   - cowboy is written in erlang, bandit was written specifically for plug, in elixir, and therefore phoenix, ridding some unused bloat
# --no-live just comments out live-view-related stuff, so uncomment it when it's needed
mix help phx.new

mix phx.new my_project --adapter bandit --no-live

cd my_project

# if you didn't make the git repo already..
git init

# Then configure your database in config/dev.exs and run:
# before this though, make sure the database is running locally:
pg_ctl start
# can check with pg_isready
mix ecto.create

# start your Phoenix app with:
# ensure you are running the terminal as admin on windows
mix phx.server

# you can also run your app inside iex (interactive elixir):
# TODO: try this another time
iex -S mix phx.serverate

# check it out! yay!! :)
http://localhost:4000/






https://thephoenixtutorial.org/book/ch1_from_zero_to_deploy
  - looks like a simple, one-page-html tutorial..

The Hex packages used by your app are found in the mix. exs file

# installs dependencies
# (asked when creating a new project)
mix deps.get

SKIPPING TUTORIAL, just go with ai and make the app




# set up a basic database

# can use this mix script to generate basic schemas (table-like data entities)
mix phx.gen.schema Thing things field_name:type name2:type2
# generates the schema file and a file that contains a script to create the table:
# creating lib/game_archive/thing.ex
# creating priv/repo/migrations/20240731053228_create_things.exs

# but i think you eventually have to edit the generated code to map relationships beyond simple foreign keys (field_name:reference:schema)

# TODO: do some reading up on ecto
# https://hexdocs.pm/ecto/Ecto.Schema.html#content
# https://hexdocs.pm/ecto/Ecto.Schema.html#has_many/3-has_many-has_one-through
# some notes:
# By default, a schema will automatically generate a primary key which is named id and of type :integer
# array in ecto = list in elixir (maybe ecto is from erlang?)
# :map

# relations
# has_many(t)
# has_one(t)
# many_to_many(t)


mix phx.gen.schema User users username:string:unique email:string:unique password_hash:string
# created_at:utc_datetime updated_at:utc_datetime
# NOTE: already generated this.. check it out!

mix phx.gen.schema Game games title:string alt_titles:array:string makers:array:references:makers release_year:integer genres:array:genres tags:array:tags short_description:string countries:array:references:countries
# can you do array of references? (table id)

mix phx.gen.schema Maker makers name:string job:references:jobs
mix phx.gen.schema Job jobs name:string

mix phx.gen.schema Country countries name:string
mix phx.gen.schema Genre genres name:string
mix phx.gen.schema Tag tags name:string

# ratings...
# game engines / tech
# languages?


# TODO: should all strings be unique?

# alt_names:array:string
mix phx.gen.schema Game games

# genre vs tag?
# itch.io uses tag
# older engines use genre

# can add and think about later
# but be warned, updating schemas isn't so simple :/
mix phx.gen.schema Media.Review reviews user_id:references:users game_id:references:games rating:integer review_text:text created_at:utc_datetime updated_at:utc_datetime
mix phx.gen.schema Media.Watchlist watchlists user_id:references:users game_id:references:games created_at:utc_datetime updated_at:utc_datetime

# much later
mix phx.gen.schema Social.Follower followers follower_id:references:users followed_id:references:users created_at:utc_datetime updated_at:utc_datetime







prompt (ms copilot):
make me a web-site similar to letterboxd using the phoenix framework (elixir)

Certainly! Building a website similar to Letterboxd using the Phoenix Framework (Elixir) is an exciting project. Letterboxd is a social platform for film enthusiasts, so we‚Äôll focus on creating a simplified version with some core features.

Before we dive into the implementation, let‚Äôs outline the key features we‚Äôll include in our Phoenix-based movie platform:

User Authentication: Users can sign up, log in, and manage their profiles.
Movie Listings: Display a list of movies with details (title, release year, genre, etc.).
User Reviews and Ratings: Allow users to rate and review movies.
Lists and Collections: Users can create and manage lists (e.g., ‚ÄúWatchlist,‚Äù ‚ÄúFavorites,‚Äù etc.).
Search and Filtering: Implement search functionality and filters for movies.
User Recommendations: Provide personalized movie recommendations based on user preferences.
Responsive Design: Ensure the website works well on different devices (desktop, tablet, mobile).
Let‚Äôs get started with the basics:

1. Setting Up Your Phoenix Project
Install Elixir and Phoenix:
Make sure you have Elixir installed. If not, follow the installation instructions from the official Elixir website.
Install the Phoenix project generator:
mix archive.install hex phx_new

Create a new Phoenix project:
mix phx.new my_movie_platform
cd my_movie_platform

2. Define Your Data Models
Create a Movie schema:
mix phx.gen.schema Movie movies title:string release_year:integer genre:string

mix phx.gen.schema Game games title:string release_year:integer genre:string

Create a User schema (for authentication):
mix phx.gen.schema User users email:string password_hash:string

3. Implement User Authentication
Set up authentication using phx.gen.auth:
mix phx.gen.auth Accounts User users

4. Create Movie Views and Controllers
Create a controller for movies:
mix phx.gen.html Movies Movie movies title:string release_year:integer genre:string

Add routes for movies in lib/my_movie_platform_web/router.ex.
5. Implement Movie Listings and Details
Create views and templates for movie listings and details.
Fetch movie data from your database and display it on the website.
6. User Reviews and Ratings
Create a Review schema (with fields like user_id, movie_id, rating, and comment).
Implement CRUD operations for reviews.
7. Lists and Collections
Create a List schema (with fields like user_id, name, and description).
Allow users to create and manage lists (e.g., watchlist, favorites).
8. Search and Filtering
Implement search functionality for movies.
Add filters (by genre, release year, etc.).
9. User Recommendations
Use collaborative filtering or content-based recommendation algorithms to suggest movies to users.
10. Styling and Responsive Design
Use CSS (or a front-end framework like Tailwind CSS) to style your website.
Ensure it looks good on different devices.
Remember that this is just a high-level overview. You‚Äôll need to dive deeper into each feature, handle validations, security, and more. Additionally, consider using Phoenix LiveView for real-time interactions (e.g., updating reviews without page reloads).

Feel free to explore additional features and make your movie platform unique! If you have any specific questions or need further guidance, feel free to ask‚ÄîI‚Äôm here to assist! üé¨üçø 12

By the way, do you have any preferences for the design or additional features you‚Äôd like to include?
